% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/setClass.R
\docType{class}
\name{predictGlycansParam-class}
\alias{predictGlycansParam-class}
\alias{predictGlycansParam}
\title{predictGlycansParam class}
\description{
An S4 class that contains the parameters for glycan prediction.
Once created the predictGlycansParam object should be supplied to the function
\link[glycanPredict]{predictGlycans} for glycan prediction constrained by the parameters contained
in the \code{predictGlycansParam} object.
}
\details{
This function is intended for “calculation” of all possible glycans (or sugars)
within a set of constraining parameters (contained within the
\code{predictGlycansParam} object). Specifically, the user indicates which
monomer types (hexose only or hexose and pentose), degree of polymerisation (length)
range and modification types should be included, the desired maximum
for the average number of modifications per monomer and whether
mono-/oligosaccharides are procainamide-labelled or not. There is also the
option for whether or not double sulphation of a single monomer is possible or not.
The function “builds” names, formulas and masses for all sugars possible
within the constraining parameters. The user also provides two parameters
related to mass spectrometry: ionisation mode (\code{ESI_mode}) and
scan range (\code{scan_range}). m/z values of ions are calculated
depending on the ionisation mode and modifications. Sugars which contain
no ions with m/z values within the given scan range are removed. The final
output is returned as a (wide format) dataframe. This package was written
for annotation of mass spec data (especially LC-MS) but if used for
other purposes either ionisation mode can be given and very wide scan ranges.
The function works by sourcing a python file and then using the function
encoded in the python script.

\strong{Word of caution: please note that this tool will predict some sugars that
are not really ‘possible’ as the nature of sugar chemistry means that it
would take a long time to add in all the constraints!}

For more details see the vignette:
\code{vignette("glycanPredict", package = "glycanPredict")}
}
\section{Slots}{

\describe{
\item{\code{dp}}{Degree of polymerisation range (numeric, length 2).}

\item{\code{polarity}}{ionisation mode used. Accepts 'pos' or 'neg'.}

\item{\code{scan_range}}{Scan range used during MS. (numeric, length 2).}

\item{\code{pent_option}}{Logical: Should pentose monomers be included?}

\item{\code{modifications}}{Modifications to be considered. Any combination of 'carboxyl', 'phosphate', 'deoxy', 'nacetyl', 'omethyl', 'anhydrobridge', 'oacetyl', 'unsaturated', 'alditol', 'amino', 'dehydrated', 'sulphate' or 'all' or 'none' (default)}

\item{\code{nmod_max}}{Maximum number of modifications per monomer on average (default 1). Does not take into account unsaturated, alditol or dehydrated.}

\item{\code{double_sulphate}}{Logical: can monomers be double-sulphated. If \code{TRUE} you MUST give a value of at least 2 to nmod_max.}

\item{\code{label}}{Are sugars labelled? Currently only accepts 'none' or 'procainamide'.}

\item{\code{ion_type}}{Ionisation type. Currently accepted ESI and MALDI. Impacts ions.}

\item{\code{naming}}{Notation for molecule names. Uses commonly accepted abbreviations. Possibilities: 'IUPAC' (default), 'Oxford', 'GlycoCT'}
}}

\examples{
pgp <- predictGlycansParam()
pgp@dp <- c(1,7)
pgp@polarity <- 'neg'
pgp@scan_range <- c(150, 1300)
pgp@modifications <- c('sulphate', 'carboxyl')
pgp@double_sulphate <- TRUE
predicted.df <- predictGlycans(param = pgp)

}
\seealso{
glycanPredict::predictGlycans()
}
